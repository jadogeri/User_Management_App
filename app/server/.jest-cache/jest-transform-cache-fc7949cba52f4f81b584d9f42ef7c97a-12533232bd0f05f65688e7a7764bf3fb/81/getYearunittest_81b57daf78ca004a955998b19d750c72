0e6881183b294b9d50a6e37f0fd65bc6
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const email_context_model_1 = require("../../../../src/models/email-context.model");
// EmailContext.getYear.spec.ts
describe('EmailContext.getYear() getYear method', () => {
    // Happy Path Tests
    it('should return the current year as a number (happy path)', () => {
        // This test aims to verify that getYear returns the current year correctly.
        const emailContext = new email_context_model_1.EmailContext();
        const expectedYear = new Date().getFullYear();
        const result = emailContext.getYear();
        expect(result).toBe(expectedYear);
        expect(typeof result).toBe('number');
    });
    it('should return a four-digit year (happy path)', () => {
        // This test aims to ensure that the returned year is a four-digit number.
        const emailContext = new email_context_model_1.EmailContext();
        const year = emailContext.getYear();
        expect(year).toBeGreaterThanOrEqual(1000);
        expect(year).toBeLessThanOrEqual(9999);
    });
    // Edge Case Tests
    it('should return correct year at the boundary of New Year (edge case)', () => {
        // This test aims to verify correct year calculation at the boundary of New Year.
        // Mock Date to Dec 31, 23:59:59
        const mockDate = new Date('2023-12-31T23:59:59.999Z');
        const spy = jest.spyOn(global, 'Date').mockImplementation(() => mockDate);
        const emailContext = new email_context_model_1.EmailContext();
        const result = emailContext.getYear();
        expect(result).toBe(2023);
        // Restore Date
        spy.mockRestore();
    });
    it('should return correct year just after New Year (edge case)', () => {
        // This test aims to verify correct year calculation just after New Year.
        // Mock Date to Jan 1, 00:00:00
        const mockDate = new Date('2024-01-02T00:00:00.000Z');
        const spy = jest.spyOn(global, 'Date').mockImplementation(() => mockDate);
        const emailContext = new email_context_model_1.EmailContext();
        const result = emailContext.getYear();
        expect(result).toEqual(2024);
        // Restore Date
        spy.mockRestore();
    });
    it('should work correctly if system date is set to a year far in the past (edge case)', () => {
        // This test aims to verify correct year calculation for a date far in the past.
        const mockDate = new Date('1900-01-02T00:00:00.000Z');
        const spy = jest.spyOn(global, 'Date').mockImplementation(() => mockDate);
        const emailContext = new email_context_model_1.EmailContext();
        const result = emailContext.getYear();
        expect(result).toBe(1900);
        // Restore Date
        spy.mockRestore();
    });
    it('should work correctly if system date is set to a year far in the future (edge case)', () => {
        // This test aims to verify correct year calculation for a date far in the future.
        const mockDate = new Date('3000-01-02T00:00:00.000Z');
        const spy = jest.spyOn(global, 'Date').mockImplementation(() => mockDate);
        const emailContext = new email_context_model_1.EmailContext();
        const result = emailContext.getYear();
        expect(result).toBe(3000);
        spy.mockRestore();
    });
    it('should not throw and should return a number even if Date is mocked to a non-standard date (edge case)', () => {
        // This test aims to verify that getYear does not throw and returns a number for a non-standard date.
        const mockDate = new Date('0001-01-02T00:00:00.000Z');
        const spy = jest.spyOn(global, 'Date').mockImplementation(() => mockDate);
        const emailContext = new email_context_model_1.EmailContext();
        const result = emailContext.getYear();
        expect(result).toBe(1);
        expect(typeof result).toBe('number');
        // Restore Date
        spy.mockRestore();
    });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXFVzZXJzXFxKb3NlcGhcXERlc2t0b3BcXFNvdXJjZVxcVXNlcl9NYW5hZ2VtZW50X0FwcFxcYXBwXFxzZXJ2ZXJcXHRlc3RzXFx1bml0XFxlbnRpdGllc1xcRW1haWxDb250ZXh0XFxnZXRZZWFyLnVuaXQudGVzdC50cyIsIm1hcHBpbmdzIjoiOztBQUFBLG9GQUEwRTtBQUkxRSwrQkFBK0I7QUFDL0IsUUFBUSxDQUFDLHVDQUF1QyxFQUFFLEdBQUcsRUFBRTtJQUNuRCxtQkFBbUI7SUFFbkIsRUFBRSxDQUFDLHlEQUF5RCxFQUFFLEdBQUcsRUFBRTtRQUMvRCw0RUFBNEU7UUFDNUUsTUFBTSxZQUFZLEdBQUcsSUFBSSxrQ0FBWSxFQUFFLENBQUM7UUFDeEMsTUFBTSxZQUFZLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUM5QyxNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNsQyxNQUFNLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDekMsQ0FBQyxDQUFDLENBQUM7SUFFSCxFQUFFLENBQUMsOENBQThDLEVBQUUsR0FBRyxFQUFFO1FBQ3BELDBFQUEwRTtRQUMxRSxNQUFNLFlBQVksR0FBRyxJQUFJLGtDQUFZLEVBQUUsQ0FBQztRQUN4QyxNQUFNLElBQUksR0FBRyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDcEMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQyxDQUFDLENBQUMsQ0FBQztJQUVILGtCQUFrQjtJQUVsQixFQUFFLENBQUMsb0VBQW9FLEVBQUUsR0FBRyxFQUFFO1FBQzFFLGlGQUFpRjtR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QyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUUxRSxNQUFNLFlBQVksR0FBRyxJQUFJLGtDQUFZLEVBQUUsQ0FBQztRQUN4QyxNQUFNLE1BQU0sR0FBRyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDdEMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN2QixNQUFNLENBQUMsT0FBTyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFckMsZUFBZTtRQUNmLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQTtJQUNyQixDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcSm9zZXBoXFxEZXNrdG9wXFxTb3VyY2VcXFVzZXJfTWFuYWdlbWVudF9BcHBcXGFwcFxcc2VydmVyXFx0ZXN0c1xcdW5pdFxcZW50aXRpZXNcXEVtYWlsQ29udGV4dFxcZ2V0WWVhci51bml0LnRlc3QudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1haWxDb250ZXh0IH0gZnJvbSBcIi4uLy4uLy4uLy4uL3NyYy9tb2RlbHMvZW1haWwtY29udGV4dC5tb2RlbFwiO1xyXG5cclxuXHJcblxyXG4vLyBFbWFpbENvbnRleHQuZ2V0WWVhci5zcGVjLnRzXHJcbmRlc2NyaWJlKCdFbWFpbENvbnRleHQuZ2V0WWVhcigpIGdldFllYXIgbWV0aG9kJywgKCkgPT4ge1xyXG4gICAgLy8gSGFwcHkgUGF0aCBUZXN0c1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHRoZSBjdXJyZW50IHllYXIgYXMgYSBudW1iZXIgKGhhcHB5IHBhdGgpJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIFRoaXMgdGVzdCBhaW1zIHRvIHZlcmlmeSB0aGF0IGdldFllYXIgcmV0dXJucyB0aGUgY3VycmVudCB5ZWFyIGNvcnJlY3RseS5cclxuICAgICAgICBjb25zdCBlbWFpbENvbnRleHQgPSBuZXcgRW1haWxDb250ZXh0KCk7XHJcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVtYWlsQ29udGV4dC5nZXRZZWFyKCk7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZShleHBlY3RlZFllYXIpO1xyXG4gICAgICAgIGV4cGVjdCh0eXBlb2YgcmVzdWx0KS50b0JlKCdudW1iZXInKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGEgZm91ci1kaWdpdCB5ZWFyIChoYXBweSBwYXRoKScsICgpID0+IHtcclxuICAgICAgICAvLyBUaGlzIHRlc3QgYWltcyB0byBlbnN1cmUgdGhhdCB0aGUgcmV0dXJuZWQgeWVhciBpcyBhIGZvdXItZGlnaXQgbnVtYmVyLlxyXG4gICAgICAgIGNvbnN0IGVtYWlsQ29udGV4dCA9IG5ldyBFbWFpbENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCB5ZWFyID0gZW1haWxDb250ZXh0LmdldFllYXIoKTtcclxuICAgICAgICBleHBlY3QoeWVhcikudG9CZUdyZWF0ZXJUaGFuT3JFcXVhbCgxMDAwKTtcclxuICAgICAgICBleHBlY3QoeWVhcikudG9CZUxlc3NUaGFuT3JFcXVhbCg5OTk5KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVkZ2UgQ2FzZSBUZXN0c1xyXG5cclxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNvcnJlY3QgeWVhciBhdCB0aGUgYm91bmRhcnkgb2YgTmV3IFllYXIgKGVkZ2UgY2FzZSknLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gVGhpcyB0ZXN0IGFpbXMgdG8gdmVyaWZ5IGNvcnJlY3QgeWVhciBjYWxjdWxhdGlvbiBhdCB0aGUgYm91bmRhcnkgb2YgTmV3IFllYXIuXHJcbiAgICAgICAgLy8gTW9jayBEYXRlIHRvIERlYyAzMSwgMjM6NTk6NTlcclxuICAgICAgICBjb25zdCBtb2NrRGF0ZSA9IG5ldyBEYXRlKCcyMDIzLTEyLTMxVDIzOjU5OjU5Ljk5OVonKTtcclxuICAgICAgICBjb25zdCBzcHkgPSBqZXN0LnNweU9uKGdsb2JhbCwgJ0RhdGUnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0RhdGUpO1xyXG5cclxuICAgICAgICBjb25zdCBlbWFpbENvbnRleHQgPSBuZXcgRW1haWxDb250ZXh0KCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZW1haWxDb250ZXh0LmdldFllYXIoKTtcclxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0JlKDIwMjMpO1xyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIERhdGVcclxuICAgICAgICBzcHkubW9ja1Jlc3RvcmUoKVxyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gY29ycmVjdCB5ZWFyIGp1c3QgYWZ0ZXIgTmV3IFllYXIgKGVkZ2UgY2FzZSknLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gVGhpcyB0ZXN0IGFpbXMgdG8gdmVyaWZ5IGNvcnJlY3QgeWVhciBjYWxjdWxhdGlvbiBqdXN0IGFmdGVyIE5ldyBZZWFyLlxyXG4gICAgICAgIC8vIE1vY2sgRGF0ZSB0byBKYW4gMSwgMDA6MDA6MDBcclxuICAgICAgICBjb25zdCBtb2NrRGF0ZSA9IG5ldyBEYXRlKCcyMDI0LTAxLTAyVDAwOjAwOjAwLjAwMFonKTtcclxuICAgICAgICBjb25zdCBzcHkgPSBqZXN0LnNweU9uKGdsb2JhbCwgJ0RhdGUnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gbW9ja0RhdGUpO1xyXG5cclxuICAgICAgICBjb25zdCBlbWFpbENvbnRleHQgPSBuZXcgRW1haWxDb250ZXh0KCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZW1haWxDb250ZXh0LmdldFllYXIoKTtcclxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKDIwMjQpO1xyXG5cclxuICAgICAgICAvLyBSZXN0b3JlIERhdGVcclxuICAgICAgICBzcHkubW9ja1Jlc3RvcmUoKVxyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCB3b3JrIGNvcnJlY3RseSBpZiBzeXN0ZW0gZGF0ZSBpcyBzZXQgdG8gYSB5ZWFyIGZhciBpbiB0aGUgcGFzdCAoZWRnZSBjYXNlKScsICgpID0+IHtcclxuICAgICAgICAvLyBUaGlzIHRlc3QgYWltcyB0byB2ZXJpZnkgY29ycmVjdCB5ZWFyIGNhbGN1bGF0aW9uIGZvciBhIGRhdGUgZmFyIGluIHRoZSBwYXN0LlxyXG4gICAgICAgIGNvbnN0IG1vY2tEYXRlID0gbmV3IERhdGUoJzE5MDAtMDEtMDJUMDA6MDA6MDAuMDAwWicpO1xyXG4gICAgICAgIGNvbnN0IHNweSA9IGplc3Quc3B5T24oZ2xvYmFsLCAnRGF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrRGF0ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVtYWlsQ29udGV4dCA9IG5ldyBFbWFpbENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBlbWFpbENvbnRleHQuZ2V0WWVhcigpO1xyXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoMTkwMCk7XHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgRGF0ZVxyXG4gICAgICAgIHNweS5tb2NrUmVzdG9yZSgpXHJcbiAgICB9KTtcclxuXHJcbiAgICBpdCgnc2hvdWxkIHdvcmsgY29ycmVjdGx5IGlmIHN5c3RlbSBkYXRlIGlzIHNldCB0byBhIHllYXIgZmFyIGluIHRoZSBmdXR1cmUgKGVkZ2UgY2FzZSknLCAoKSA9PiB7XHJcbiAgICAgICAgLy8gVGhpcyB0ZXN0IGFpbXMgdG8gdmVyaWZ5IGNvcnJlY3QgeWVhciBjYWxjdWxhdGlvbiBmb3IgYSBkYXRlIGZhciBpbiB0aGUgZnV0dXJlLlxyXG4gICAgICAgIGNvbnN0IG1vY2tEYXRlID0gbmV3IERhdGUoJzMwMDAtMDEtMDJUMDA6MDA6MDAuMDAwWicpO1xyXG4gICAgICAgIGNvbnN0IHNweSA9IGplc3Quc3B5T24oZ2xvYmFsLCAnRGF0ZScpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiBtb2NrRGF0ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGVtYWlsQ29udGV4dCA9IG5ldyBFbWFpbENvbnRleHQoKTtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBlbWFpbENvbnRleHQuZ2V0WWVhcigpO1xyXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoMzAwMCk7XHJcblxyXG4gICAgICAgIHNweS5tb2NrUmVzdG9yZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaXQoJ3Nob3VsZCBub3QgdGhyb3cgYW5kIHNob3VsZCByZXR1cm4gYSBudW1iZXIgZXZlbiBpZiBEYXRlIGlzIG1vY2tlZCB0byBhIG5vbi1zdGFuZGFyZCBkYXRlIChlZGdlIGNhc2UpJywgKCkgPT4ge1xyXG4gICAgICAgIC8vIFRoaXMgdGVzdCBhaW1zIHRvIHZlcmlmeSB0aGF0IGdldFllYXIgZG9lcyBub3QgdGhyb3cgYW5kIHJldHVybnMgYSBudW1iZXIgZm9yIGEgbm9uLXN0YW5kYXJkIGRhdGUuXHJcbiAgICAgICAgY29uc3QgbW9ja0RhdGUgPSBuZXcgRGF0ZSgnMDAwMS0wMS0wMlQwMDowMDowMC4wMDBaJyk7XHJcbiAgICAgICAgY29uc3Qgc3B5ID0gamVzdC5zcHlPbihnbG9iYWwsICdEYXRlJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IG1vY2tEYXRlKTtcclxuXHJcbiAgICAgICAgY29uc3QgZW1haWxDb250ZXh0ID0gbmV3IEVtYWlsQ29udGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGVtYWlsQ29udGV4dC5nZXRZZWFyKCk7XHJcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgxKTtcclxuICAgICAgICBleHBlY3QodHlwZW9mIHJlc3VsdCkudG9CZSgnbnVtYmVyJyk7XHJcblxyXG4gICAgICAgIC8vIFJlc3RvcmUgRGF0ZVxyXG4gICAgICAgIHNweS5tb2NrUmVzdG9yZSgpXHJcbiAgICB9KTtcclxufSk7Il0sInZlcnNpb24iOjN9