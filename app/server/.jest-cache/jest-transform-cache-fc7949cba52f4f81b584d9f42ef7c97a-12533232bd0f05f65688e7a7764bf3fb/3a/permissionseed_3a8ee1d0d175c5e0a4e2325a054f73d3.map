{"file":"C:\\Users\\Joseph\\Desktop\\Source\\User_Management_App\\app\\server\\src\\database\\seeds\\permission.seed.ts","mappings":";;AAGA,wEAA8D;AAC9D,gEAAwD;AAExD,MAAqB,gBAAgB;IACrC;;;;;;;SAOK;IACI,KAAK,CAAC,GAAG,CAAC,UAAsB;QACrC,MAAM,oBAAoB,GAAG,UAAU,CAAC,aAAa,CAAC,8BAAU,CAAC,CAAC;QAElE,KAAK,MAAM,UAAU,IAAI,6BAAW,EAAE,CAAC;YACrC,yCAAyC;YACzC,0FAA0F;YAE1F,6BAA6B;YAC7B,qDAAqD;YACrD,yFAAyF;YACzF,6CAA6C;YAC7C,mJAAmJ;YACnJ,QAAQ;YACR,IAAI;YAEA,yDAAyD;YAC/D,MAAM,oBAAoB,CAAC,MAAM,CAC/B,UAAU,EACV,CAAC,IAAI,CAAC,CACP,CAAC;YAEF,kDAAkD;YAClD,MAAM,eAAe,GAAG,MAAM,oBAAoB,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,UAAU,CAAC,EAAE,EAAE,CAAC,CAAC;YACpF,IAAI,eAAe,EAAE,CAAC;gBACpB,MAAM,oBAAoB,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,gDAAgD;YACpG,CAAC;QACD,CAAC;IACH,CAAC;CACF;AArCD,mCAqCC","names":[],"sources":["C:\\Users\\Joseph\\Desktop\\Source\\User_Management_App\\app\\server\\src\\database\\seeds\\permission.seed.ts"],"sourcesContent":["// src/database/seeds/RoleSeeder.ts\r\nimport { DataSource } from 'typeorm';\r\nimport { Seeder } from 'typeorm-extension';\r\nimport { Permission } from '../../entities/permission.entity';\r\nimport { permissions} from '../../data/permission.data';\r\n\r\nexport default class PermissionSeeder implements Seeder {\r\n/**\r\n   * Checks for the existence of predefined status entities in the database \r\n   * and saves them if they do not already exist. \r\n   * \r\n   * @param dataSource - The data source used to access the repository.\r\n   * @returns A promise that resolves to void.\r\n   * @throws Any errors thrown by the repository methods during execution.\r\n   */\r\n  public async run(dataSource: DataSource): Promise<void> {\r\n    const permissionRepository = dataSource.getRepository(Permission);\r\n\r\n    for (const permission of permissions) {\r\n      // Check if the role already exists by ID\r\n      // const existingPermission = await permissionRepository.findOneBy({ id: permission.id });\r\n      \r\n      // if (!existingPermission) {\r\n      //   await permissionRepository.upsert(permissions, {\r\n      //       conflictPaths: [\"action\", \"resource\",\"id\"], // Columns that trigger the conflict\r\n      //       upsertType: \"on-conflict-do-update\",\r\n      //       overwriteCondition: { where: { description: () => \"EXCLUDED.description\" } }, // ðŸ‘ˆ ONLY update description, keep ID and Foreign Keys safe\r\n      //   });\r\n      // }\r\n\r\n          // Use upsert for the Role itself to prevent ID conflicts\r\n    await permissionRepository.upsert(\r\n      permission,\r\n      [\"id\"]\r\n    );\r\n\r\n    // Re-fetch the role to establish relations safely\r\n    const savedPermission = await permissionRepository.findOneBy({ id: permission.id });\r\n    if (savedPermission) {\r\n      await permissionRepository.save(savedPermission); // TypeORM handles role_permission automatically\r\n    }\r\n    }\r\n  }\r\n}\r\n"],"version":3}